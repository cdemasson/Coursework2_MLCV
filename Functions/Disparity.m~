%                        Disparity map function
% Function Inputs: 
% IL: Left image
% IR: Right image 
% Range: Disparity range
% W: Window size, defined as the thickness of the window. So a W value of 
% would result in a 3x3 window. A W value of 2 would result in a 5x5 window

function  DisparityMap = Disparity(IL,IR,W) 
DisparityMap = zeros(size((IL),1),size((IL),2)); 
IL = rgb2gray(IL); 
IR = rgb2gray(IR); 
    % Iterate through all the rows (Y Coordinates)
    for row =  1 : size(IL,1) 
        % Iterate through all the cols (X Coordinates) 
        for col = 1 : size(IL,2)
            % Calculate the window ranges 
            XminL = boundary(col - W,col,IL); 
            XmaxL = boundary(col + W,col,IL); 
            Ymin = boundary(row - W,row,IL); 
            Ymax = boundary(row + W,row,IL); 
            %Initialise the SSD to an unrealistically large value 
            SSDmin = 10000000;     
            % Iterate through the disparity range 
            for Xr = 1 : size(IL,2) 
                % Subtract 1 to start at 0 disparity
                % Shift the centre of the right window
                XminR = boundary((Xr) - W,(Xr),IL); 
                XmaxR = boundary((Xr) + W,(Xr),IL); 
                
                %           Dealing with four more boundary cases: 
                % Case 1: First column of left image
                if (col == 1) 
                    XminR = boundary((Xr),(Xr),IL);
                end 
                % Case 2: Last column of left image
                if (col == size(IL,2)) 
                    XmaxR = boundary((Xr),(Xr),IL); 
                end 
                % Calculate window sizes 
                Lwindow = IL(Ymin:Ymax,XminL:XmaxL);
                Rwindow = IR(Ymin:Ymax,XminR:XmaxR);
                
                % Case 3: First column of right image
                if (Xr == 1 && isequal(size(Rwindow), [2 2]) && col ~=1) 
                    XminLtemp = boundary(col,col,IL);
                    % Recalculate left window size
                    Lwindow = IL(Ymin:Ymax,XminLtemp:XmaxL); 
                end 
                % Case 4: last column of right image
                if (Xr == size(IL,2) && isequal(size(Rwindow), [2 2]) && col ~=size(IL,2)) 
                    XmaxLtemp = boundary(col,col,IL); 
                    % Recalculate left window size
                    Lwindow = IL(Ymin:Ymax,XminL:XmaxLtemp); 
                end 
                
                try 
                SSDcurrent = sum(sum((Lwindow - Rwindow).^2)); 
                catch 
                    disp("Problem: Window sizes do not match") 
                    pause()
                end 
                % If the current SSD is less than the minimum, assign the
                % disparity and update the minimum SSD
                try
                if (SSDcurrent < SSDmin) 
                    SSDmin = SSDcurrent; 
                    DisparityMap(row,col) = abs(col-Xr); 
                end 
                catch 
                    disp("Problem calculating the SSD") 
                    pause()
                end 
                
            end 
        end
    end 
    
% <<<<<<<<<<<<<     BOUNDARY CASE CHECKING FUNCTION  >>>>>>>>>>>>>>>>>>>>>
    function K = boundary(RangeValue,PixelPosition,IL,X) 
        % Case 1: Less than or equal to 1
        if (RangeValue <= 0) 
            K = PixelPosition;  
        % Case 2: Bigger than the image size 
        elseif (RangeValue > size(IL,1) ||  RangeValue > size(IL,2))
            K = PixelPosition; 
        else 
            K = RangeValue; 
        end 
    end     
end 

